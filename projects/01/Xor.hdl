// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Xor.hdl

/**
 *  Exclusive-or gate: out = !(a == b).
 */

CHIP Xor {

    IN a, b;
    OUT out;

    PARTS:
    // Working backwards here, the output we want is:
    // 0
    // 1
    // 1
    // 0
    // Nand is only false when both a and b are 1.
    // So Nand of this truth table:
    // a1 b1
    // 1  1
    // 1  0
    // 0  1
    // 1  1
    // will produce the output we want.
    // How do we get there?
    // Well again, Nand of 1 0 or 0 1 is true, so looking at the base
    // truth table
    // 0 0
    // 0 1
    // 1 0
    // 1 1
    // the top and bottom lines are 0 0 and 1 1respctively, 
    // a notb and b nota get us the tables we need.  I think lining
    // the truth tables up like this helps (remember a and b are the base truth table)
    // a  notb  b  nota
    // 0  1     0  1
    // 0  0     1  1
    // 1  1     0  0
    // 1  0     0  1
    // If we Nand the above 2 truth tables above we get the truth table we want:
    // a2 b1
    // 1  1
    // 1  0
    // 0  1
    // 1  1

    Not(in=a,             out=nota);
    Not(in=b,             out=notb);
    Nand(a=a,     b=notb, out=a1);
    Nand(a=nota,  b=b,    out=b1);
    Nand(a=a1,    b=b1,   out=out);
}
/*
    // A less efficent but perhapse clearer implementation?
    // Again, going backwards, this time useing Or of
    // a1 b1
    // 0  0
    // 0  1
    // 1  0
    // 0  0
    // will give us the output we want.
    // looking at the a notb, b nota tables above,
    // two And operations do the trick.

    Not(in=a,            out=nota);
    Not(in=b,            out=notb);
    And(a=a,     b=notb, out=a1);
    And(a=nota,  b=b,    out=b1);
    Or (a=a1,    b=b1,   out=out);
*/
